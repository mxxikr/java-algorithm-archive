package Greedy;

/**
 * ### 문제 설명
 *
 * 높이가 다른 N개의 빌딩 블록이 있습니다. 이 블록들을 일렬로 배열하여 '상승 구간'을 가장 많이 만들고자 합니다.
 * '상승 구간'이란, 배열된 블록 중 k번째 블록이 k-1번째 블록보다 높이가 높은 경우를 의미하며, 이것을 한 개의 상승 구간으로 셉니다.
 *
 * 예를 들어, 높이 [3, 5, 2]의 블록이 주어졌을 때, [2, 3, 5] 순서로 배열하면,
 * 상승 구간은 (2 -> 3), (3 -> 5) 두 개가 됩니다.
 * 만약 [5, 2, 3]으로 배열하면 상승 구간은 (2 -> 3) 한 개입니다.
 *
 * 블록 높이가 담긴 배열 `blocks`가 주어질 때, 블록을 자유롭게 재배열하여 만들 수 있는 상승 구간의 최대 개수를 반환하는 함수를 완성하세요.
 *
 * ### 제한사항
 *
 * * 블록의 개수 N : 1 이상 100,000 이하의 자연수
 * * 블록의 높이 : 1 이상 1,000,000 이하의 자연수
 *
 * ### 입출력 예
 *
 * | blocks          | answer |
 * | :-------------- | :----- |
 * | [3, 2, 1, 4, 5] | 4      |
 * | [10, 20, 10, 20]| 2      |
 * | [5, 5, 5, 5]    | 0      |
 *
 * ### 입출력 예 설명
 *
 * **예시 #1**
 *   블록 [3, 2, 1, 4, 5]를 [1, 2, 3, 4, 5]로 재배열하면, (1->2), (2->3), (3->4), (4->5) 총 4개의 상승 구간을 만들 수 있습니다.
 *
 * **예시 #2**
 *   블록 [10, 20, 10, 20]의 경우, 가장 흔한 높이(10과 20)가 각각 2번 나타납니다.
 *   [10, 20, 10, 20]으로 배열하면 (10->20), (10->20)의 상승 구간 2개를 만들 수 있습니다. 이것이 최댓값입니다.
 *   총 블록 개수(4)에서 가장 흔한 블록의 개수(2)를 뺀 값과 같습니다.
 *
 * **예시 #3**
 *   모든 블록의 높이가 5로 동일합니다. 어떻게 배열해도 상승 구간을 만들 수 없습니다.
 *   총 블록 개수(4)에서 가장 흔한 블록의 개수(4)를 뺀 값은 0입니다.
 */
public class LongestAscendingSequence {
}
